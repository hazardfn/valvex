<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/hazardfn/valvex/_build/test/cover/eunit/valvex_server.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/hazardfn/valvex/_build/test/lib/valvex/ebin/../src/valvex_server.erl by COVER 2016-07-26 at 15:34:39

****************************************************************************

        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%% @author Howard Beard-Marlowe &lt;howardbm@live.se&gt;
        |  %%% @copyright 2016 Howard Beard-Marlowe
        |  %%% @version 0.1.0
        |  %%% @end
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  
        |  %% @doc Valvex Server
        |  %%
        |  %% The server is responsible for queue management as well
        |  %% as sending events and pushback.
        |  
        |  -module(valvex_server).
        |  
        |  -behaviour(gen_server).
        |  
        |  %% API exports
        |  -export([ add/3
        |          , add_handler/3
        |          , remove/3
        |          , remove_handler/3
        |          , push/3
        |          , get_available_workers/1
        |          , get_queue_size/2
        |          , start_link/1
        |          , notify/2
        |          , pushback/2
        |          , update/3
        |          ]).
        |  
        |  -export([ code_change/3
        |          , handle_call/3
        |          , handle_cast/2
        |          , handle_info/2
        |          , init/1
        |          , terminate/2
        |          ]).
        |  
        |  -type valvex_state() :: #{ queues            =&gt; [valvex:valvex_queue()]
        |                           , queue_pids        =&gt; [tuple()]
        |                           , pushback          =&gt; true | false
        |                           , workers           =&gt; [pid()]
        |                           , event_server      =&gt; valvex:valvex_ref() | undefined
        |                           , available_workers =&gt; [pid()]
        |                           }.
        |  
        |  %%======================================================================================================================
        |  %% API functions
        |  %%======================================================================================================================
        |  %% @doc Starts a link to the valvex server
        |  -spec start_link(valvex:valvex_options()) -&gt; valvex:valvex_ref().
        |  start_link(Options) -&gt;
    22..|    {ok, Pid} = gen_server:start_link({local, valvex}, ?MODULE, Options, []),
    22..|    Pid.
        |  
        |  %% @doc Adds a queue to valvex, there are some alternative options
        |  %% that can be used to alter the behaviour of add.
        |  %% @see valvex:add_option()
        |  -spec add(valvex:valvex_ref(), valvex:valvex_queue(), valvex:add_option()) -&gt; ok | valvex:unique_key_error().
        |  add(Valvex, { _Key
        |              , {threshold, _Threshold}
        |              , {timeout, _Timeout, seconds}
        |              , {pushback, _Pushback, seconds}
        |              , {poll_rate, _Poll, ms}
        |              , _Backend
        |              } = Q, Option) -&gt;
    22..|    do_add(Valvex, Q, Option).
        |  
        |  %% @doc Removes a queue from valvex, there are some alternative options
        |  %% that can be used to alter the behaviour of remove.
        |  %% @see valvex:remove_option()
        |  -spec remove(valvex:valvex_ref(), valvex:queue_key(), valvex:remove_option()) -&gt; ok | valvex:key_find_error().
        |  remove(Valvex, Key, Option) -&gt;
    12..|    do_remove(Valvex, Key, Option).
        |  
        |  %% @doc Pushes an item to a queue with a specific key.
        |  -spec push( valvex:valvex_ref(), valvex:queue_key(), valvex:valvex_q_item()) -&gt; ok.
        |  push(Valvex, Key, Value) -&gt;
    74..|    do_push(Valvex, Key, Value).
        |  
        |  %% @doc Gets available workers, as in those that aren't currently
        |  %% undertaking work.
        |  -spec get_available_workers(valvex:valvex_ref()) -&gt; valvex:valvex_workers().
        |  get_available_workers(Valvex) -&gt;
     4..|    do_get_workers(Valvex).
        |  
        |  %% @doc Gets the current size of the queue with the given key.
        |  -spec get_queue_size( valvex:valvex_ref(), valvex:queue_key()) -&gt; non_neg_integer() | valvex:key_find_error().
        |  get_queue_size(Valvex, Key) -&gt;
 25514..|    do_get_queue_size(Valvex, Key).
        |  
        |  %% @doc Pushes back on the client forcing them to wait
        |  %% this prevents spamming if enabled.
        |  -spec pushback(valvex:valvex_ref(), valvex:queue_key()) -&gt; ok.
        |  pushback(Valvex, Key) -&gt;
     8..|    do_pushback(Valvex, Key).
        |  
        |  %% @doc Notifies all registered event handlers of an event
        |  %% within valvex, read the readme for more info.
        |  -spec notify( valvex:valvex_ref(), any()) -&gt; ok.
        |  notify(Valvex, Event) -&gt;
   628..|    do_notify(Valvex, Event).
        |  
        |  %% @doc Adds a handler which will receive events from valvex, view
        |  %% the readme for more info on events.
        |  -spec add_handler(valvex:valvex_ref(), module(), list()) -&gt; ok.
        |  add_handler(Valvex, Module, Args) -&gt;
    24..|    do_add_handler(Valvex, Module, Args).
        |  
        |  %% @doc Removes a handler so it will no longer receive events.
        |  -spec remove_handler(valvex:valvex_ref(), module(), list()) -&gt; ok.
        |  remove_handler(Valvex, Module, Args) -&gt;
     2..|    do_remove_handler(Valvex, Module, Args).
        |  
        |  %% @doc Updates a queue after a crossover
        |  %% @private
        |  -spec update(valvex:valvex_ref(), valvex:queue_key(), valvex:valvex_queue()) -&gt; ok.
        |  update(Valvex, Key, Q) -&gt;
     4..|    do_update(Valvex, Key, Q).
        |  
        |  %%======================================================================================================================
        |  %% Gen Server Callbacks
        |  %%======================================================================================================================
        |  %% @doc Inititalizes valvex with predefined queues, settings and
        |  %% event handlers
        |  -spec init([tuple()]) -&gt; {ok, valvex_state()}.
        |  init([ {queues, Queues}
        |       , {pushback_enabled, Pushback}
        |       , {workers, WorkerCount}
        |       , {event_handlers, EventHandlers}
        |       ]) -&gt;
    22..|    process_flag(trap_exit, true),
    22..|    gen_server:cast(self(), {init, Queues, Pushback, WorkerCount, EventHandlers}),
    22..|    {ok, #{ queues            =&gt; []
        |          , queue_pids        =&gt; []
        |          , pushback          =&gt; false
        |          , workers           =&gt; []
        |          , event_server      =&gt; undefined
        |          , available_workers =&gt; []
        |          }};
        |  %% @doc starts the server with default settings.
        |  init([]) -&gt;
<font color=red>     0..|    process_flag(trap_exit, true),</font>
<font color=red>     0..|    Workers = start_workers(10),</font>
<font color=red>     0..|    {ok, EventServer} = gen_event:start_link(),</font>
<font color=red>     0..|    {ok, #{ queues            =&gt; []</font>
        |          , queue_pids        =&gt; []
        |          , pushback          =&gt; false
        |          , workers           =&gt; Workers
        |          , event_server      =&gt; EventServer
        |          , available_workers =&gt; Workers
        |          }}.
        |  
        |  %% @doc see the "see also" section for a list of synchronous operations
        |  %% @see add()
        |  %% @see get_available_workers()
        |  %% @see remove()
        |  %% @see add_handler()
        |  %% @see remove_handler()
        |  %% @see update()
        |  handle_call({get_queue, Key}, _From, #{ queue_pids := Queues } = S) -&gt;
 25556..|    case lists:keyfind(Key, 1, Queues) of
        |      false -&gt;
    20..|        {reply, {error, key_not_found}, S};
        |      {Key, _Backend} = Queue -&gt;
 25536..|        lager:info("get_queue found: ~p", [Queue]),
 25536..|        {reply, Queue, S}
        |    end;
        |  handle_call({get_raw_queue, Key}, _From, #{ queue_pids := Queues
        |                                            , queues     := RawQueues
        |                                            } = S) -&gt;
   106..|    case lists:keyfind(Key, 1, Queues) of
        |      false -&gt;
     8..|        {reply, {error, key_not_found}, S};
        |      {Key, _Backend} -&gt;
    98..|        RawQ = lists:keyfind(Key, 1, RawQueues),
    98..|        lager:info("get_raw_queue found: ~p", [RawQ]),
    98..|        {reply, RawQ, S}
        |    end;
        |  handle_call({add, { Key
        |                    , _Threshold
        |                    , _Timeout
        |                    , _Pushback
        |                    , _Poll
        |                    , Backend
        |                    } = Q, Option}, _From, #{ queues       := Queues
        |                                            , queue_pids   := QPids
        |                                            } = S) -&gt;
    12..|    NewQueues = lists:append(Queues, [Q]),
    12..|    valvex_queue_sup:start_child([Backend, Key, Q]),
    12..|    if
        |      Option /= manual_start -&gt;
    10..|        valvex_queue:start_consumer(Backend, Key);
     2..|      true -&gt; ok
        |    end,
    12..|    NewQPids  = lists:append(QPids, [{Key, Backend}]),
    12..|    lager:info("queue added: ~p", [Q]),
    12..|    {reply, ok, S#{ queues     := NewQueues
        |                  , queue_pids := NewQPids
        |                  }};
        |  handle_call(get_workers, _From, #{ available_workers := Workers } = S) -&gt;
     4..|    lager:info("List of workers requested: ~p", [Workers]),
     4..|    {reply, Workers, S};
        |  handle_call( {assign_work, {Work, Timestamp}, {Key, QPid, Backend}}
        |             , _From, #{ available_workers := Workers } = S) -&gt;
    38..|    case Workers == [] of
        |      false -&gt;
     4..|        [Worker | T] = Workers,
     4..|        Valvex = self(),
     4..|        WorkFun = fun() -&gt;
     4..|                      valvex:notify(Valvex, {result, Work(), Key})
        |                  end,
     4..|        valvex:notify(Valvex, {worker_assigned, Key, Worker, T}),
     4..|        valvex_worker:work(Worker, {work, WorkFun}),
     4..|        {noreply, S#{ available_workers := T }};
        |      true -&gt;
    34..|        valvex:notify(self(), {work_requeued, Key, []}),
    34..|        valvex_queue:push_r(Backend, QPid, {Work, Timestamp}),
    34..|        {noreply, S}
        |    end;
        |  handle_call({remove, Key}, _From, #{ queues     := Queues
        |                                     , queue_pids := QPids
        |                                     } = S) -&gt;
     8..|    supervisor:terminate_child(valvex_queue_sup, Key),
     8..|    {reply, ok, S#{ queues     := lists:keydelete(Key, 1, Queues)
        |                  , queue_pids := lists:keydelete(Key, 1, QPids)
        |                  }};
        |  handle_call( {add_handler, Module, Args}
        |             , _From
        |             , #{ event_server := EventServer} = S
        |             ) -&gt;
    24..|    lager:info("Handler added Module:~p, Args:~p", [Module, Args]),
    24..|    ok = gen_event:add_sup_handler(EventServer, Module, Args),
    24..|    {reply, ok, S};
        |  handle_call( {remove_handler, Module, Args}
        |             , _From
        |             , #{ event_server := EventServer} = S
        |             ) -&gt;
     2..|    lager:info("Handler removed Module:~p, Args:~p", [Module, Args]),
     2..|    ok = gen_event:delete_handler(EventServer, Module, Args),
     2..|    {reply, ok, S};
        |  handle_call({update, Key, { Key
        |                            , _
        |                            , _
        |                            , _
        |                            , _
        |                            , Backend} = Q}, _From, #{ queues     := Queues
        |                                                    , queue_pids := QPids
        |                                                    } = S) -&gt;
     4..|    lager:info("Queue options updated Key:~p, Update:~p", [Key, Q]),
     4..|    NewQueues = lists:append(lists:keydelete(Key, 1, Queues), [Q]),
     4..|    NewQPids  = lists:append(lists:keydelete(Key, 1, QPids), [{Key, Backend}]),
     4..|    {reply, ok, S#{ queues     := NewQueues
        |                  , queue_pids := NewQPids }};
        |  handle_call(get_queues, _From, #{queues := Queues} = S) -&gt;
   384..|    {reply, Queues, S}.
        |  
        |  handle_cast({pushback, Key}, #{ queues := Queues } = S) -&gt;
     8..|    case lists:keyfind(Key, 1, Queues) of
        |      {Key, _, _, {pushback, Pushback, seconds}, _, _} = Q -&gt;
     8..|        Valvex = self(),
     8..|        spawn(fun() -&gt;
     8..|                  TimeoutMS = timer:seconds(Pushback),
     8..|                  timer:sleep(TimeoutMS),
     8..|                  notify(Valvex, {threshold_hit, Q})
        |              end),
     8..|        {noreply, S};
        |      false -&gt;
<font color=red>     0..|        {noreply, S}</font>
        |    end;
        |  handle_cast({push, Key, Value}, #{queue_pids := Queues} = S) -&gt;
    74..|    case lists:keyfind(Key, 1, Queues) of
        |      false -&gt;
<font color=red>     0..|        {noreply, S};</font>
        |      {Key, Backend} -&gt;
    74..|        case maybe_locked(Key, Backend) of
        |          false -&gt;
    70..|            lager:info("Work pushed - Key:~p, Value:~p", [Key, Value]),
    70..|            valvex_queue:push(Backend, Key, Value),
    70..|            {noreply, S};
        |          true -&gt;
     4..|            lager:warning("Pushed to a locked queue: ~p", [Key]),
     4..|            valvex:notify(self(), {push_to_locked_queue, Key}),
     4..|            {noreply, S}
        |        end
        |    end;
        |  handle_cast( {work_finished, WorkerPid}
        |             , #{ available_workers := Workers } = S) -&gt;
     2..|    lager:info("Work has finished and a worker has been free'd: ~p", [WorkerPid]),
     2..|    {noreply, S#{ available_workers := lists:append(Workers, [WorkerPid]) }};
        |  handle_cast({notify, Event}
        |             , #{ event_server := EventServer } = S
        |             ) -&gt;
   604..|    lager:info("Event sent to subscribers: ~p", [Event]),
   604..|    gen_event:notify(EventServer, Event),
   604..|    {noreply, S};
        |  handle_cast({init, Queues, Pushback, WorkerCount, EventHandlers}, _S) -&gt;
    22..|    {ok, EventServer} = gen_event:start_link(),
    22..|    HandlerFun = fun({EventModule, Args}) -&gt;
    22..|                     gen_event:add_handler(EventServer, EventModule, Args)
        |                 end,
    22..|    lists:foreach(HandlerFun, EventHandlers),
    22..|    QueueFun = fun({ Key
        |                   , _Threshold
        |                   , _Timeout
        |                   , _Pushback
        |                   , _Poll
        |                   , Backend
        |                   } = Q) -&gt;
    66..|                   valvex_queue_sup:start_child([Backend, Key, Q]),
    66..|                   valvex_queue:start_consumer(Backend, Key),
    66..|                   [{Key, Backend}]
        |               end,
    22..|    Workers = start_workers(WorkerCount),
    22..|    {noreply, #{ queues            =&gt; Queues
        |               , queue_pids        =&gt; lists:flatmap(QueueFun, Queues)
        |               , pushback          =&gt; Pushback
        |               , workers           =&gt; Workers
        |               , event_server      =&gt; EventServer
        |               , available_workers =&gt; Workers
        |               }}.
        |  
        |  handle_info(_Info, S) -&gt;
     2..|    {noreply, S}.
        |  
        |  code_change(_Vsn, S, _Extra) -&gt;
<font color=red>     0..|    {ok, S}.</font>
        |  
        |  terminate(_Reason, #{ workers := Workers, queue_pids := QPids} = _S) -&gt;
    22..|    StopWorkerFun = fun(Worker) -&gt;
    22..|                        valvex_worker:stop(Worker)
        |                    end,
    22..|    StopQueueFun = fun({Key, _Backend}) -&gt;
    70..|                       supervisor:terminate_child(valvex_queue_sup, Key)
        |                   end,
    22..|    lists:foreach(StopWorkerFun, Workers),
    22..|    lists:foreach(StopQueueFun, QPids),
    22..|    ok.
        |  
        |  %%==============================================================================
        |  %% Internal functions
        |  %%==============================================================================
        |  
        |  get_queue(Valvex, Key) -&gt;
 25556..|    gen_server:call(Valvex, {get_queue, Key}).
        |  
        |  do_add(Valvex, {Key, _, _, _, _, _} = Q, undefined) -&gt;
    12..|    case get_queue(Valvex, Key) of
        |      {error, key_not_found} -&gt;
    10..|        gen_server:call(Valvex, {add, Q, undefined});
        |      _ -&gt;
     2..|        lager:error("Attempted to add a non-unique key: ~p", [Key]),
     2..|        {error, key_not_unique}
        |    end;
        |  do_add(Valvex, {Key, _, _, _, _, Backend} = Q, crossover_on_existing) -&gt;
    16..|    case get_queue(Valvex, Key) of
        |      {error, key_not_found} -&gt;
     8..|        do_add(Valvex, Q, undefined);
        |      {Key, Backend} -&gt;
     4..|        valvex_queue:crossover(Backend, Key, Q);
        |      _ -&gt;
     4..|        lager:error("Attempted to switch backend/key - operation not supported"),
     4..|        {error, backend_key_crossover_not_supported}
        |    end;
        |  do_add(Valvex, {Key, _, _, _, _, Backend} = Q, manual_start) -&gt;
     2..|    case get_queue(Valvex, Key) of
        |      {error, key_not_found} -&gt;
     2..|        gen_server:call(Valvex, {add, Q, manual_start});
        |      {Key, Backend} -&gt;
<font color=red>     0..|        lager:error("Attempted to add a non-unique key: ~p", [Key]),</font>
<font color=red>     0..|        {error, key_not_unique}</font>
        |    end.
        |  
        |  do_remove(Valvex, Key, undefined) -&gt;
     2..|    case get_queue(Valvex, Key) of
        |      {Key, Backend} -&gt;
     2..|        valvex_queue:tombstone(Backend, Key);
        |      {error, key_not_found} = Error -&gt;
<font color=red>     0..|        lager:error("Attempted to remove a non-existing key: ~p", [Key]),</font>
<font color=red>     0..|        Error</font>
        |    end;
        |  do_remove(Valvex, Key, lock_queue) -&gt;
     2..|    case get_queue(Valvex, Key) of
        |      {Key, Backend} -&gt;
     2..|        valvex_queue:lock(Backend, Key),
     2..|        valvex_queue:tombstone(Backend, Key);
        |      {error, key_not_found} = Error -&gt;
<font color=red>     0..|        lager:error("Attempted to remove a non-existing key: ~p", [Key]),</font>
<font color=red>     0..|        Error</font>
        |    end;
        |  do_remove(Valvex, Key, force_remove) -&gt;
     8..|    case get_queue(Valvex, Key) of
        |      {Key, _Backend}          -&gt;
     8..|        gen_server:call(Valvex, {remove, Key});
        |      {error, key_not_found} = Error -&gt;
<font color=red>     0..|        lager:error("Attempted to remove a non-existing key: ~p", [Key]),</font>
<font color=red>     0..|        Error</font>
        |    end.
        |  
        |  do_push(Valvex, Key, Value) -&gt;
    74..|    gen_server:cast(Valvex, {push, Key, Value}).
        |  
        |  do_get_workers(Valvex) -&gt;
     4..|    gen_server:call(Valvex, get_workers).
        |  
        |  do_get_queue_size(Valvex, Key) -&gt;
 25514..|    case get_queue(Valvex, Key) of
        |      {Key, Backend} -&gt;
 25514..|        valvex_queue:size(Backend, Key);
        |      Error -&gt;
<font color=red>     0..|        Error</font>
        |    end.
        |  
        |  do_pushback(Valvex, Key) -&gt;
     8..|    gen_server:cast(Valvex, {pushback, Key}).
        |  
        |  do_notify(Valvex, Event) -&gt;
   628..|    gen_server:cast(Valvex, {notify, Event}).
        |  
        |  do_add_handler(Valvex, Module, Args) -&gt;
    24..|    gen_server:call(Valvex, {add_handler, Module, Args}).
        |  
        |  do_remove_handler(Valvex, Module, Args) -&gt;
     2..|    gen_server:call(Valvex, {remove_handler, Module, Args}).
        |  
        |  do_update(Valvex, Key, Q) -&gt;
     4..|    gen_server:call(Valvex, {update, Key, Q}).
        |  
        |  start_workers(WorkerCount) -&gt;
    22..|    lists:flatmap(fun(_) -&gt;
    22..|                      [valvex_worker:start_link(self())]
        |                  end, lists:seq(1, WorkerCount)).
        |  
        |  maybe_locked(Key, Backend) -&gt;
    74..|    case whereis(Key) of
<font color=red>     0..|      undefined -&gt; false;</font>
    74..|      Pid -&gt; valvex_queue:is_locked(Backend, Pid)
        |    end.
        |  
        |  %%%_* Emacs ====================================================================
        |  %%% Local Variables:
        |  %%% allout-layout: t
        |  %%% erlang-indent-level: 2
        |  %%% End:
</pre>
</body>
</html>
