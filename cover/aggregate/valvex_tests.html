<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/travis/build/hazardfn/valvex/_build/test/cover/aggregate/valvex_tests.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/travis/build/hazardfn/valvex/_build/test/lib/valvex/test/valvex_tests.erl by COVER 2016-06-26 at 16:04:08

****************************************************************************

        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%% @doc valvex tests
        |  %%% @copyright 2016 Howard Beard-Marlowe
        |  %%% @end
        |  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        |  %%%_* Module declaration =======================================================
        |  -module(valvex_tests).
        |  
        |  -export([ test_add/1
        |          , test_consumer/1
        |          , test_crossover/1
        |          , test_crossover_errors/1
        |          , test_get_available_workers/1
        |          , test_locking/1
        |          , test_pop/1
        |          , test_pop_r/1
        |          , test_pushback/1
        |          , test_remove/1
        |          , test_tombstone/1
        |          ]).
        |  
        |  -export([ all/0
        |          , all/1
        |          , suite/0
        |          , init_per_suite/1
        |          , init_per_testcase/2
        |          , end_per_suite/1
        |          , end_per_testcase/2
        |          ]).
        |  
        |  %%%_* Includes =================================================================
        |  -include_lib("common_eunit/include/common_eunit.hrl").
        |  %%%_* Suite Callbacks ==========================================================
        |  suite() -&gt;
     2..|    [{timetrap, {seconds, 60}}].
        |  
        |  init_per_suite(Config) -&gt;
     1..|    application:get_all_env(valvex) ++ Config.
        |  
        |  end_per_suite(Config) -&gt;
     1..|    Config.
        |  
        |  init_per_testcase(TestCase, Config) -&gt;
    11..|    test_forwarder:start_link(),
    11..|    Pid = erlang:spawn(test_message_handler, loop, []),
    11..|    application:ensure_all_started(valvex),
    11..|    valvex:add_handler(valvex, valvex_message_event_handler, [Pid]),
    11..|    ?MODULE:TestCase({init, Config}).
        |  
        |  end_per_testcase(TestCase, Config)  -&gt;
    11..|    application:stop(valvex),
    11..|    application:stop(cowboy),
    11..|    application:stop(lager),
    11..|    application:unload(lager),
    11..|    application:unload(cowboy),
    11..|    application:unload(valvex),
    11..|    gen_server:stop(test_forwarder),
    11..|    ?MODULE:TestCase({'end', Config}).
        |  
        |  all() -&gt;
     2..|    all(suite).
        |  all(suite) -&gt;
     2..|    [ test_add
        |    , test_consumer
        |    , test_crossover
        |    , test_crossover_errors
        |    , test_get_available_workers
        |    , test_locking
        |    , test_pop
        |    , test_pop_r
        |    , test_pushback
        |    , test_remove
        |    , test_tombstone
        |    ].
        |  
        |  %%%_ * Tests ===================================================================
<font color=red>     0..|  test_add(suite)                         -&gt; [];</font>
     1..|  test_add({init, Config})                -&gt; Config;
     1..|  test_add({'end', _Config})              -&gt; ok;
        |  test_add(doc)                           -&gt;
<font color=red>     0..|    ["Test we can add queues using the various options"];</font>
        |  test_add(Config) when is_list(Config)   -&gt;
     1..|    Valvex = valvex,
     1..|    KeyLifo      = test_lifo,
     1..|    KeyFifo      = test_fifo,
     1..|    KeyNew       = test_new,
     1..|    KeyManual    = test_manual,
     1..|    NewConFun    = fun() -&gt;
     1..|                       valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyNew)
        |                   end,
     1..|    ManualConFun = fun() -&gt;
     1..|                       valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyManual)
        |                   end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Add a new queue
     1..|    ?assertEqual(ok, valvex:add(Valvex, { KeyNew
        |                                        , {threshold, 3000}
        |                                        , {timeout, 20, seconds}
        |                                        , {pushback, 20, seconds}
        |                                        , {poll_rate, 3000, ms}
        |                                        , valvex_queue_fifo_backend
     1..|                                        })),
     1..|    ?assert(is_pid(whereis(KeyNew))),
     1..|    ?assert(NewConFun()),
        |    %% Try adding it again and verify we get an error
     1..|    ?assertEqual({error, key_not_unique}, valvex:add(Valvex, { KeyNew
        |                                                             , {threshold, 3000}
        |                                                             , {timeout, 20, seconds}
        |                                                             , {pushback, 20, seconds}
        |                                                             , {poll_rate, 3000, ms}
        |                                                             , valvex_queue_fifo_backend
     1..|                                                             })),
        |    %% Add a manual_start queue and verify the consumer is dead
     1..|    ?assertEqual(ok, valvex:add(Valvex, { KeyManual
        |                                        , {threshold, 3000}
        |                                        , {timeout, 20, seconds}
        |                                        , {pushback, 20, seconds}
        |                                        , {poll_rate, 3000, ms}
        |                                        , valvex_queue_fifo_backend
     1..|                                        }, manual_start)),
     1..|    ?assertEqual(false, ManualConFun()).
        |  
<font color=red>     0..|  test_consumer(suite)                         -&gt; [];</font>
     1..|  test_consumer({init, Config})                -&gt; Config;
     1..|  test_consumer({'end', _Config})              -&gt; ok;
        |  test_consumer(doc)                           -&gt;
<font color=red>     0..|    ["Test we can add queues using the various options"];</font>
        |  test_consumer(Config) when is_list(Config)   -&gt;
     1..|    Valvex  = valvex,
     1..|    KeyLifo = test_lifo,
     1..|    KeyFifo = test_fifo,
     1..|    WorkFun = fun() -&gt; timer:sleep(3000) end,
     1..|    LifoSizeFun = fun() -&gt; valvex:get_queue_size(Valvex, KeyLifo) end,
     1..|    FifoSizeFun = fun() -&gt; valvex:get_queue_size(Valvex, KeyFifo) end,
     1..|    LifoPushFun = fun(_N) -&gt; valvex:push(Valvex, KeyLifo, WorkFun) end,
     1..|    FifoPushFun = fun(_N) -&gt; valvex:push(Valvex, KeyFifo, WorkFun) end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Ensure the consumer is started
     1..|    ?assert(valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assert(valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Push some work and monitor to ensure the queue returns to 0
     1..|    Seq = lists:seq(0, 10),
     1..|    lists:foreach(LifoPushFun, Seq),
     1..|    lists:foreach(FifoPushFun, Seq),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 0, 999999)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 0, 999999)),
        |    %% Ensure stopping the consumer twice doesn't cause errors
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Ensure starting the consumer twice doesn't cause errors
     1..|    ?assertEqual(ok, valvex_queue:start_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:start_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(ok, valvex_queue:start_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:start_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(true, valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(true, valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)).
        |  
<font color=red>     0..|  test_crossover(suite)                         -&gt; [];</font>
     1..|  test_crossover({init, Config})                -&gt; Config;
     1..|  test_crossover({'end', _Config})              -&gt; ok;
        |  test_crossover(doc)                           -&gt;
<font color=red>     0..|    ["Test we can change queue settings"];</font>
        |  test_crossover(Config) when is_list(Config)   -&gt;
     1..|    Valvex = valvex,
     1..|    KeyLifo = test_lifo,
     1..|    KeyFifo = test_fifo,
     1..|    RawLifoFun = fun() -&gt;
     2..|                     gen_server:call(Valvex, {get_raw_queue, KeyLifo})
        |                 end,
     1..|    RawFifoFun = fun() -&gt;
     2..|                     gen_server:call(Valvex, {get_raw_queue, KeyFifo})
        |                 end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Get the raw queues for comparison
     1..|    RawQLifo = RawLifoFun(),
     1..|    RawQFifo = RawFifoFun(),
        |    %% Set new parameters and initiate a crossover
     1..|    UpdatedQLifo = { KeyLifo
        |                   , {threshold, 3000}
        |                   , {timeout, 20, seconds}
        |                   , {pushback, 20, seconds}
        |                   , {poll_rate, 3000, ms}
        |                   , valvex_queue_lifo_backend
        |                   },
     1..|    ?assertNotEqual(RawQLifo, UpdatedQLifo),
     1..|    UpdatedQFifo = { KeyFifo
        |                   , {threshold, 3000}
        |                   , {timeout, 20, seconds}
        |                   , {pushback, 20, seconds}
        |                   , {poll_rate, 3000, ms}
        |                   , valvex_queue_fifo_backend
        |                   },
     1..|    ?assertNotEqual(RawQFifo, UpdatedQFifo),
     1..|    valvex:add(Valvex, UpdatedQLifo, crossover_on_existing),
     1..|    valvex:add(Valvex, UpdatedQFifo, crossover_on_existing),
        |    %% Verify the queues are updated
     1..|    ?assertEqual(ok, do_until(RawLifoFun, UpdatedQLifo, 999999)),
     1..|    ?assertEqual(ok, do_until(RawFifoFun, UpdatedQFifo, 999999)).
        |  
<font color=red>     0..|  test_crossover_errors(suite)                         -&gt; [];</font>
     1..|  test_crossover_errors({init, Config})                -&gt; Config;
     1..|  test_crossover_errors({'end', _Config})              -&gt; ok;
        |  test_crossover_errors(doc)                           -&gt;
<font color=red>     0..|    ["Check that certain types of crossovers are not allowed"];</font>
        |  test_crossover_errors(Config) when is_list(Config)   -&gt;
     1..|    Valvex = valvex,
     1..|    KeyLifo = test_lifo,
     1..|    KeyFifo = test_fifo,
     1..|    RawLifoFun = fun() -&gt;
     2..|                     gen_server:call(Valvex, {get_raw_queue, KeyLifo})
        |                 end,
     1..|    RawFifoFun = fun() -&gt;
     2..|                     gen_server:call(Valvex, {get_raw_queue, KeyFifo})
        |                 end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Get the raw queues for comparison
     1..|    RawQLifo = RawLifoFun(),
     1..|    RawQFifo = RawFifoFun(),
        |    %% Set new illegal parameters and initiate a crossover
     1..|    UpdatedKeyQLifo = { test_lifo_new
        |                      , {threshold, 3000}
        |                      , {timeout, 20, seconds}
        |                      , {pushback, 20, seconds}
        |                      , {poll_rate, 3000, ms}
        |                      , valvex_queue_lifo_backend
        |                      },
     1..|    UpdatedBackendQLifo = { test_lifo
        |                          , {threshold, 3000}
        |                          , {timeout, 20, seconds}
        |                          , {pushback, 20, seconds}
        |                          , {poll_rate, 3000, ms}
        |                          , valvex_queue_fifo_backend
        |                          },
     1..|    UpdatedBothQLifo = { test_lifo_other
        |                       , {threshold, 3000}
        |                       , {timeout, 20, seconds}
        |                       , {pushback, 20, seconds}
        |                       , {poll_rate, 3000, ms}
        |                       , valvex_queue_fifo_backend
        |                       },
     1..|    ?assertNotEqual(RawQLifo, UpdatedKeyQLifo),
     1..|    ?assertNotEqual(RawQLifo, UpdatedBackendQLifo),
     1..|    ?assertNotEqual(RawQLifo, UpdatedBothQLifo),
     1..|    UpdatedKeyQFifo = { test_fifo_new
        |                      , {threshold, 3000}
        |                      , {timeout, 20, seconds}
        |                      , {pushback, 20, seconds}
        |                      , {poll_rate, 3000, ms}
        |                      , valvex_queue_fifo_backend
        |                      },
     1..|    UpdatedBackendQFifo = { test_fifo
        |                          , {threshold, 3000}
        |                          , {timeout, 20, seconds}
        |                          , {pushback, 20, seconds}
        |                          , {poll_rate, 3000, ms}
        |                          , valvex_queue_lifo_backend
        |                          },
     1..|    UpdatedBothQFifo = { test_fifo_other
        |                       , {threshold, 3000}
        |                       , {timeout, 20, seconds}
        |                       , {pushback, 20, seconds}
        |                       , {poll_rate, 3000, ms}
        |                       , valvex_queue_lifo_backend
        |                       },
     1..|    ?assertNotEqual(RawQFifo, UpdatedKeyQFifo),
     1..|    ?assertNotEqual(RawQFifo, UpdatedBackendQFifo),
     1..|    ?assertNotEqual(RawQFifo, UpdatedBothQFifo),
        |    %% Trigger the update and hope for errors in some of the cases
        |    %% A new key is basically a request for a new queue, it will be handled
        |    %% as such
     1..|    ?assertEqual( ok
     1..|                , valvex:add(Valvex, UpdatedKeyQLifo, crossover_on_existing)),
        |    %% A new backend is tricky to crossover without losing data so this is
        |    %% not supported
     1..|    ?assertEqual( {error, backend_key_crossover_not_supported}
     1..|                , valvex:add(Valvex, UpdatedBackendQLifo, crossover_on_existing)),
        |    %% Updating both is basically a request for a new queue.
     1..|    ?assertEqual( ok
     1..|                , valvex:add(Valvex, UpdatedBothQLifo, crossover_on_existing)),
        |  
        |    %% A new key is basically a request for a new queue, it will be handled
        |    %% as such
     1..|    ?assertEqual( ok
     1..|                , valvex:add(Valvex, UpdatedKeyQFifo, crossover_on_existing)),
        |    %% A new backend is tricky to crossover without losing data so this is
        |    %% not supported
     1..|    ?assertEqual( {error, backend_key_crossover_not_supported}
     1..|                , valvex:add(Valvex, UpdatedBackendQFifo, crossover_on_existing)),
        |    %% Updating both is basically a request for a new queue.
     1..|    ?assertEqual( ok
     1..|                , valvex:add(Valvex, UpdatedBothQFifo, crossover_on_existing)),
        |  
        |    %% Verify the queues are the same as when we started
     1..|    ?assertEqual(ok, do_until(RawLifoFun, RawQLifo, 999999)),
     1..|    ?assertEqual(ok, do_until(RawFifoFun, RawQFifo, 999999)).
        |  
<font color=red>     0..|  test_get_available_workers(suite)                         -&gt; [];</font>
     1..|  test_get_available_workers({init, Config})                -&gt; Config;
     1..|  test_get_available_workers({'end', _Config})              -&gt; ok;
        |  test_get_available_workers(doc)                           -&gt;
<font color=red>     0..|    ["Test get available workers api call"];</font>
        |  test_get_available_workers(Config) when is_list(Config)   -&gt;
     1..|    Valvex   = valvex,
     1..|    [Worker] = valvex:get_available_workers(Valvex),
     1..|    ?assert(is_pid(Worker)),
     1..|    ?assert(erlang:is_process_alive(Worker)),
     1..|    ?assertEqual(1, valvex:get_available_workers_count(Valvex)).
        |  
<font color=red>     0..|  test_locking(suite)                         -&gt; [];</font>
     1..|  test_locking({init, Config})                -&gt; Config;
     1..|  test_locking({'end', _Config})              -&gt; ok;
        |  test_locking(doc)                           -&gt;
<font color=red>     0..|    ["Test locking mechanisms"];</font>
        |  test_locking(Config) when is_list(Config)   -&gt;
     1..|    Valvex      = valvex,
     1..|    KeyLifo     = test_lifo,
     1..|    KeyFifo     = test_fifo,
     1..|    WorkFun     = fun() -&gt;
<font color=red>     0..|                      timer:sleep(1000)</font>
        |                  end,
     1..|    LifoConFun  = fun() -&gt;
     1..|                      valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)
        |                  end,
     1..|    LifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyLifo)
        |                  end,
     1..|    FifoConFun  = fun() -&gt;
     1..|                      valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)
        |                  end,
     1..|    FifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyFifo)
        |                  end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Lock both the queues
     1..|    ?assertEqual(ok, valvex_queue:lock(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:lock(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assert(valvex_queue:is_locked(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assert(valvex_queue:is_locked(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Check pushing to a locked queue leaves it empty
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, WorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, WorkFun)),
     1..|    ?assertEqual(0, valvex:get_queue_size(Valvex, KeyLifo)),
     1..|    ?assertEqual(0, valvex:get_queue_size(Valvex, KeyFifo)),
        |    %% Test we can unlock the queues
     1..|    ?assertEqual(ok, valvex_queue:unlock(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:unlock(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(false, valvex_queue:is_locked(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(false, valvex_queue:is_locked(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Test once they are unlocked they can be pushed to
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(ok, do_until(LifoConFun, false, 999999)),
     1..|    ?assertEqual(ok, do_until(FifoConFun, false, 999999)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, WorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, WorkFun)),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 1, 999999)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 1, 999999)).
        |  
<font color=red>     0..|  test_pop(suite)                         -&gt; [];</font>
     1..|  test_pop({init, Config})                -&gt; Config;
     1..|  test_pop({'end', _Config})              -&gt; ok;
        |  test_pop(doc)                           -&gt;
<font color=red>     0..|    ["Test pop works and pops in the expected order"];</font>
        |  test_pop(Config) when is_list(Config)   -&gt;
     1..|    Valvex       = valvex,
     1..|    KeyLifo       = test_lifo,
     1..|    KeyFifo       = test_fifo,
     1..|    LifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyLifo)
        |                  end,
     1..|    FifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyFifo)
        |                  end,
     1..|    FirstWorkFun  = fun() -&gt; 1 end,
     1..|    SecondWorkFun = fun() -&gt; 2 end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Stop the consumer so we can pop manually
     1..|      ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Push work to the queues
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, FirstWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, SecondWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, FirstWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, SecondWorkFun)),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 2, 999999)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 2, 999999)),
        |    %% Pop queues and check correct order
     1..|    ?assertMatch({{value, {SecondWorkFun, _}}, _}, valvex_queue:pop(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertMatch({{value, {FirstWorkFun, _}}, _}, valvex_queue:pop(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertMatch({{value, {FirstWorkFun, _}}, _}, valvex_queue:pop(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertMatch({{value, {SecondWorkFun, _}}, _}, valvex_queue:pop(valvex_queue_fifo_backend, KeyFifo)).
        |  
<font color=red>     0..|  test_pop_r(suite)                         -&gt; [];</font>
     1..|  test_pop_r({init, Config})                -&gt; Config;
     1..|  test_pop_r({'end', _Config})              -&gt; ok;
        |  test_pop_r(doc)                           -&gt;
<font color=red>     0..|    ["Test pop_r is the reverse of pop"];</font>
        |  test_pop_r(Config) when is_list(Config)   -&gt;
     1..|    Valvex       = valvex,
     1..|    KeyLifo       = test_lifo,
     1..|    KeyFifo       = test_fifo,
     1..|    LifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyLifo)
        |                  end,
     1..|    FifoSizeFun = fun() -&gt;
     1..|                      valvex:get_queue_size(Valvex, KeyFifo)
        |                  end,
     1..|    FirstWorkFun  = fun() -&gt; 1 end,
     1..|    SecondWorkFun = fun() -&gt; 2 end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Stop the consumer so we can pop manually
     1..|      ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(false, valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Push work to the queues
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, FirstWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, SecondWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, FirstWorkFun)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, SecondWorkFun)),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 2, 999999)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 2, 999999)),
        |    %% Pop queues and check correct order
     1..|    ?assertMatch({{value, {FirstWorkFun, _}}, _}, valvex_queue:pop_r(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertMatch({{value, {SecondWorkFun, _}}, _}, valvex_queue:pop_r(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertMatch({{value, {SecondWorkFun, _}}, _}, valvex_queue:pop_r(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertMatch({{value, {FirstWorkFun, _}}, _}, valvex_queue:pop_r(valvex_queue_fifo_backend, KeyFifo)).
        |  
<font color=red>     0..|  test_pushback(suite)                         -&gt; [];</font>
     1..|  test_pushback({init, Config})                -&gt; Config;
     1..|  test_pushback({'end', _Config})              -&gt; ok;
        |  test_pushback(doc)                           -&gt;
<font color=red>     0..|    ["Test pushback works"];</font>
        |  test_pushback(Config) when is_list(Config)   -&gt;
     1..|    Valvex  = valvex,
     1..|    KeyLifo = test_lifo,
     1..|    KeyFifo = test_fifo,
     1..|    {_, BeforeSeconds, _} = os:timestamp(),
        |    %% Begin pushback
     1..|    valvex:add_handler(Valvex, valvex_message_event_handler, [self()]),
     1..|    valvex:pushback(Valvex, KeyLifo),
     1..|    receive
        |      {threshold_hit, _} -&gt;
     1..|        ok
        |    end,
     1..|    valvex:pushback(Valvex, KeyFifo),
     1..|    receive
        |      {threshold_hit, _} -&gt;
     1..|        ok
        |    end,
     1..|    valvex:remove_handler(Valvex, valvex_message_event_handler, []),
        |    %% Compare time
     1..|    {_, CurrentSeconds, _} = os:timestamp(),
     1..|    Diff = CurrentSeconds - BeforeSeconds,
     1..|    ?assert(Diff &gt;= 2).
        |  
<font color=red>     0..|  test_remove(suite)                         -&gt; [];</font>
     1..|  test_remove({init, Config})                -&gt; Config;
     1..|  test_remove({'end', _Config})              -&gt; ok;
        |  test_remove(doc)                           -&gt;
<font color=red>     0..|    ["Test we can remove queues and all the possible scenarios"];</font>
        |  test_remove(Config) when is_list(Config)   -&gt;
     1..|    Valvex      = valvex,
     1..|    KeyLifo     = test_lifo,
     1..|    KeyFifo     = test_fifo,
     1..|    KeyPBTest   = test_threshold_pushback,
     1..|    RawLifoFun  = fun() -&gt;
    26..|                      gen_server:call(Valvex, {get_raw_queue, KeyLifo})
        |                  end,
     1..|    LifoSizeFun = fun() -&gt;
    15..|                      valvex:get_queue_size(Valvex, KeyLifo)
        |                  end,
     1..|    LifoConFun  = fun() -&gt;
     2..|                      valvex_queue:is_consuming(valvex_queue_lifo_backend, KeyLifo)
        |                  end,
     1..|    RawFifoFun  = fun() -&gt;
<font color=red>     0..|                      gen_server:call(Valvex, {get_raw_queue, KeyFifo})</font>
        |                  end,
     1..|    FifoSizeFun = fun() -&gt;
     2..|                      valvex:get_queue_size(Valvex, KeyFifo)
        |                  end,
     1..|    FifoConFun  = fun() -&gt;
     1..|                      valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyFifo)
        |                  end,
     1..|    RawPBTestFun = fun() -&gt;
     1..|                       gen_server:call(Valvex, {get_raw_queue, KeyPBTest})
        |                   end,
     1..|    PBTestConFun  = fun() -&gt;
     1..|                        valvex_queue:is_consuming(valvex_queue_fifo_backend, KeyPBTest)
        |                    end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
     1..|    ?assert(is_pid(whereis(KeyPBTest))),
        |    %% Stop the consumer of the lifo queue so we can test it hangs around
        |    %% when a normal remove is done
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, do_until(LifoConFun, false, 999999)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyLifo, RawLifoFun)),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 1, 999999)),
     1..|    ?assertEqual(ok, valvex:remove(Valvex, KeyLifo)),
     1..|    ?assertEqual(true, valvex_queue:is_tombstoned(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:start_consumer(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, do_until(LifoConFun, true, 999999)),
     1..|    ?assertEqual(ok, do_until(LifoSizeFun, 0, 999999)),
     1..|    ?assertEqual(ok, do_until(RawLifoFun, {error, key_not_found}, 999999)),
        |    %% Stop the consumer of the fifo queue so we can test locking
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(ok, do_until(FifoConFun, false, 9999999)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyFifo, RawFifoFun)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 1, 9999999)),
     1..|    ?assertEqual(ok, valvex:remove(Valvex, KeyFifo, lock_queue)),
     1..|    ?assert(valvex_queue:is_locked(valvex_queue_fifo_backend, KeyFifo)),
        |    %% Push work to the PBTest queue so we can be sure force remove doesn't care
     1..|    ?assertEqual(ok, valvex_queue:stop_consumer(valvex_queue_fifo_backend, KeyPBTest)),
     1..|    ?assertEqual(ok, do_until(PBTestConFun, false, 999999)),
     1..|    ?assertEqual(ok, valvex:push(Valvex, KeyPBTest, RawPBTestFun)),
     1..|    ?assertEqual(ok, do_until(FifoSizeFun, 1, 9999999)),
     1..|    ?assertEqual(ok, valvex:remove(Valvex, KeyPBTest, force_remove)),
     1..|    ?assertEqual(ok, do_until(RawPBTestFun, {error, key_not_found}, 999999)).
        |  
<font color=red>     0..|  test_tombstone(suite)                         -&gt; [];</font>
     1..|  test_tombstone({init, Config})                -&gt; Config;
     1..|  test_tombstone({'end', _Config})              -&gt; ok;
        |  test_tombstone(doc)                           -&gt;
<font color=red>     0..|    ["Test tombstone mechanisms"];</font>
        |  test_tombstone(Config) when is_list(Config)   -&gt;
     1..|    Valvex     = valvex,
     1..|    KeyLifo    = test_lifo,
     1..|    KeyFifo    = test_fifo,
     1..|    RawLifoFun = fun() -&gt;
    23..|                     gen_server:call(Valvex, {get_raw_queue, KeyLifo})
        |                 end,
     1..|    RawFifoFun = fun() -&gt;
     1..|                     gen_server:call(Valvex, {get_raw_queue, KeyFifo})
        |                 end,
        |    %% Make sure the queues are started as expected
     1..|    ?assert(is_pid(whereis(KeyLifo))),
     1..|    ?assert(is_pid(whereis(KeyFifo))),
        |    %% Tombstone both queues
     1..|    ?assertEqual(ok, valvex_queue:tombstone(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assertEqual(ok, valvex_queue:tombstone(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assert(valvex_queue:is_tombstoned(valvex_queue_lifo_backend, KeyLifo)),
     1..|    ?assert(valvex_queue:is_tombstoned(valvex_queue_fifo_backend, KeyFifo)),
     1..|    ?assertEqual(ok, do_until(RawLifoFun, {error, key_not_found}, 999999)),
     1..|    ?assertEqual(ok, do_until(RawFifoFun, {error, key_not_found}, 999999)).
        |  
        |  do_until(Fun, ExpectedResult, 0) -&gt;
<font color=red>     0..|    throw({unexpected_result, Fun(), ExpectedResult});</font>
        |  do_until(Fun, ExpectedResult, N) -&gt;
 17610..|    case Fun() of
        |      ExpectedResult -&gt;
    26..|        lager:info("Expected Result was given: ~p", [ExpectedResult]),
    26..|        ok;
        |      Other              -&gt;
 17584..|        lager:info("Unxpected Result was given attempting again: ~p", [Other]),
 17584..|        do_until(Fun, ExpectedResult, N-1)
        |    end.
        |  
        |  %%%_* Emacs ============================================================
        |  %%% Local Variables:
        |  %%% allout-layout: t
        |  %%% erlang-indent-level: 2
        |  %%% End:
</pre>
</body>
</html>
